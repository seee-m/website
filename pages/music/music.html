<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music Player</title>
    <link rel="stylesheet" href="../../shared.css">
    <link rel="stylesheet" href="music.css">
    <link rel="stylesheet" href="../../directory-component.css">
</head>

<body>
    <header class="header">
        <div class="box title-box">
            <div class="title-box-top">
                <span class="title">[c-m] advanced network<br>enabled music player</span>

                <svg class="svg-logo" viewBox="0 0 1263.1 659.03">
                     <g transform="translate(-.00038379 -.00037995)">
                     <path d="m9.8047 0.0097656c-3.8859 0.2244-6.4393 4.5235-5.3164 20.77 0 0 2.0391 74.786 2.0391 82.986v169.04c-1.0133 16.387-3.0661 80.934-6.1328 91.174-2.0533 7.173 4.0921 13.32 14.332 13.32l104.46-1.0274c-1.0267 20.493-1.0284 262.28-6.1484 281.75 0 0 186.39-5.134 207.89 0v-32.787c-8.2 1.027-118.8 6.1461-126.99 5.1191-11.267 1.027-24.573-1.0272-22.533-32.787v-108.59c-1.0267-7.174 1.0252-14.346 20.479-14.346 0 0 108.56-2.0539 114.69 2.0391v-31.76c-9.2133 1.027-108.55 5.1331-118.79 3.0801-7.1733 0-15.361 3.0799-15.361-15.373v-53.268c16.387-1.027 112.65-10.24 163.85-99.373 24.573-52.254 37.893-141.39-7.1738-202.85-26.627-36.88-57.346-78.893-207.88-73.76-27.653 0-87.053 1.027-100.36 0-3.075-0.76987-6.4372-2.6905-9.3301-3.2246-0.60268-0.11128-1.1851-0.16292-1.7402-0.13086zm109.24 25.199c30.915 0.23925 54.916 3.5056 84.105 11.955 92.173 27.667 93.186 118.84 93.186 151.63 0 56.347-15.359 85.04-24.572 100.4h-153.61c2.0533 7.173 0 53.282 0 63.521h-40.961c-24.573 0-18.439-21.509-18.439-28.682v-265.35c0-34.84 9.227-31.761 26.627-32.787 12.29-0.5135 23.363-0.7692 33.668-0.68945zm77.959 288.57h56.332c-7.1733 10.253-30.733 37.906-80.906 37.906v-21.506c0-10.254-1.0258-16.4 24.574-16.4z"/>
                     <path d="m532.9 1.3125c-5.12 0-6.1322 4.0922-8.1856 8.1992 0 0-151.56 362.67-160.77 369.84 0 0 28.667-5.1196 43 1.0274l45.066-129.09c4.0933-7.173 5.1194-12.293 28.666-12.293h96.268c11.267 0 20.48-7.1739 28.68 17.412l48.119 121.92c12.293-2.053 61.454-4.0924 66.574-1.0254 0 0-160.79-353.45-162.83-368.81-3.08-6.146-7.1736-7.1719-13.32-7.1719zm-6.0156 83.047c2.5145-0.47822 4.8228 3.4312 8.0703 9.9258l45.053 104.24c5.1333 12.814-4.6008 12.294-8.1875 12.814-4.0933 0-33.787 1.0117-38.92 1.0117h-17.4c-5.12 0-32.266-1.5332-32.266-1.5332-14.84 0-11.267-12.799-8.707-16.906l45.574-99.627c2.7475-6.5275 4.8275-9.5538 6.7832-9.9258z"/>
                     <path d="m532.9 279.98c-5.12 0-6.1322 4.0926-8.1856 8.1855 0 0-151.56 362.68-160.77 369.86 0 0 28.667-5.1353 43 1.0117l45.066-129.08c4.0933-7.173 5.1194-12.293 28.666-12.293h96.268c11.267 0 20.48-7.1729 28.68 17.414l48.119 121.92c12.293-2.053 61.454-4.1073 66.574-1.0274 0 0-160.79-353.45-162.83-368.81-3.08-6.147-7.1736-7.1738-13.32-7.1738zm-6.0156 83.043c2.5145-0.4771 4.8228 3.4345 8.0703 9.9297l45.053 104.24c5.1333 12.8-4.6008 12.291-8.1875 12.801-4.0933 0-33.787 1.0273-38.92 1.0273h-17.4c-5.12 0-32.266-1.5352-32.266-1.5352-14.84-1e-5 -11.267-12.813-8.707-16.906l45.574-99.627c2.7475-6.5332 4.8275-9.5586 6.7832-9.9297z"/>
                     <path d="m1075.7 1.3125c-5.12 0-6.1323 4.0922-8.1856 8.1992 0 0-151.56 362.67-160.79 369.84 0 0 28.68-5.1196 43.014 1.0274l45.066-129.09c4.0933-7.173 5.1193-12.293 28.666-12.293h96.268c11.267 0 20.48-7.1739 28.68 17.412l48.119 121.92c12.293-2.053 61.454-4.0924 66.574-1.0254 0 0-160.79-353.45-162.83-368.81-3.08-6.146-7.1736-7.1719-13.32-7.1719zm-6.0157 83.047c2.5145-0.47822 4.8228 3.4312 8.0703 9.9258l45.053 104.24c5.12 12.814-4.6008 12.294-8.1875 12.814-4.0933 0-33.8 1.0117-38.92 1.0117h-17.398c-5.12 0-32.268-1.5332-32.268-1.5332-14.84 0-11.267-12.799-8.707-16.906l45.574-99.627c2.7475-6.5275 4.8275-9.5538 6.7832-9.9258z"/>
                     <path d="m1075.7 279.98c-5.12 0-6.1323 4.0926-8.1856 8.1855 0 0-151.56 362.68-160.79 369.86 0 0 28.68-5.1353 43.014 1.0117l45.066-129.08c4.0933-7.173 5.1193-12.293 28.666-12.293h96.268c11.267 0 20.48-7.1729 28.68 17.414l48.119 121.92c12.293-2.053 61.454-4.1073 66.574-1.0274 0 0-160.79-353.45-162.83-368.81-3.08-6.147-7.1736-7.1738-13.32-7.1738zm-6.0157 83.043c2.5145-0.4771 4.8228 3.4345 8.0703 9.9297l45.053 104.24c5.12 12.8-4.6008 12.291-8.1875 12.801-4.0933 0-33.8 1.0273-38.92 1.0273h-17.398c-5.12 0-32.268-1.5352-32.268-1.5352-14.84-1e-5 -11.267-12.813-8.707-16.906l45.574-99.627c2.7475-6.5332 4.8275-9.5586 6.7832-9.9297z"/>
                     <path d="m789.95 259.48h56.32v-225.39c12.293 0 96.267 2.04 109.57 6.146-2.04-4.613-2.04-28.693 1.0267-35.853-15.36 1.013-85 4.093-116.75 4.093h-40.96c-12.293 0-111.63-1.026-120.84-5.12 4.0933 10.24 0 33.8-1.0267 35.854 11.267-1.027 70.667-3.08 112.65-3.08v223.35"/>
                     <path d="m789.95 659.03h56.32"/>
                     <path d="m786.87 315.83v187.48c0 16.4-2.04 150.6-5.12 154.71h63.493c2.0533-15.374-4.0933-92.214-4.0933-157.77v-145.48c0.507-6.146 0-40.466 0-40.466v-0.52c12.293 0 101.39 2.053 114.69 6.146-2.04-4.6-2.04-28.68 1.0267-35.853-15.36 1.027-85 4.093-116.75 4.093h-40.96c-12.293 0-111.63-1.013-120.84-5.12 4.0933 10.254 0 33.814-1.0267 35.867 11.267-1.027 67.587-3.08 109.57-3.08"/>
                    </g>
                </svg>
            </div>

            <div class="title-box-bottom">
                <button id="directoryToggle">[DIRECTORY]</button>
                <div style="display: flex; gap: 10px; margin-left: auto;">
                    <button id="hideShowBtn">[HIDE BROWSER]</button>
                    <button id="playPauseBtn">[PLAY]</button>
                </div>
            </div>
        </div>

        <div class="box controls-box" id="controlsBox">
            <p id="nowPlaying">NO FILE LOADED</p>
            <p id="timeDisplay">0:00 / 0:00</p>
        </div>
        
        <div class="box playlist-box" id="playlistBox">
            <div class="playlist-scroll" id="playlistScroll">
                <ul class="track-list" id="trackList"></ul>
            </div>
        </div>
    </header>

    <canvas id="fireworks"></canvas>
    <audio id="audioPlayer"></audio>

    <script>
        let manifest = null;

        let currentPath = 'root';
        let currentFiles = [];
        let currentTrackIndex = -1;
        let isPlaying = false;

        const audioPlayer = document.getElementById('audioPlayer');
        const trackList = document.getElementById('trackList');
        const nowPlaying = document.getElementById('nowPlaying');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const hideShowBtn = document.getElementById('hideShowBtn');
        const timeDisplay = document.getElementById('timeDisplay');
        const controlsBox = document.getElementById('controlsBox');
        const playlistBox = document.getElementById('playlistBox');
        const playlistScroll = document.getElementById('playlistScroll');

        async function loadManifest() {
            try {
                const response = await fetch('music-manifest.json');
                manifest = await response.json();
                loadFiles();
            } catch (error) {
                console.error('Failed to load manifest:', error);
                nowPlaying.textContent = 'ERROR LOADING MANIFEST';
            }
        }

        function loadFiles() {
            if (!manifest) return;

            const items = [];

            if (currentPath === 'root') {
                manifest.folders.forEach(folder => {
                    items.push({ name: folder.name, type: 'folder' });
                });
                manifest.files.forEach(file => {
                    items.push({ name: file, type: 'audio' });
                });
            } else {
                const folder = manifest.folders.find(f => f.name === currentPath);
                if (folder) {
                    folder.files.forEach(file => {
                        items.push({ name: file, type: 'audio' });
                    });
                }
            }

            currentFiles = items;
            renderTracks();
        }

        function renderTracks() {
            trackList.innerHTML = '';
            // pathDisplay.textContent = currentPath === 'root' ? '/MUSIC' : `/MUSIC/${currentPath}`.toUpperCase();

            if (currentPath !== 'root') {
                const li = document.createElement('li');
                li.className = 'track-item parent-folder';
                li.innerHTML = '<span class="track-name">[PARENT]</span><span class="track-type">&lt;DIR&gt;</span>';
                li.onclick = navigateUp;
                trackList.appendChild(li);
            }

            currentFiles.forEach((item, index) => {
                const li = document.createElement('li');
                
                if (item.type === 'folder') {
                    li.className = 'track-item';
                    li.innerHTML = `<span class="track-name">${item.name}</span><span class="track-type">&lt;DIR&gt;</span>`;
                    li.onclick = () => navigateInto(item.name);
                } else {
                    li.className = 'track-item audio';
                    li.innerHTML = `<span class="track-name">${item.name}</span>`;
                    const audioFiles = currentFiles.filter(f => f.type === 'audio');
                    const audioIndex = audioFiles.findIndex(f => f.name === item.name);
                    li.onclick = () => playFile(audioIndex);
                }
                
                trackList.appendChild(li);
            });
        }

        function navigateInto(folderName) {
            currentPath = folderName;
            loadFiles();
        }

        function navigateUp() {
            currentPath = 'root';
            loadFiles();
        }

        function playFile(index) {
            const audioFiles = currentFiles.filter(f => f.type === 'audio');
            currentTrackIndex = index;
            const file = audioFiles[index];
            
            if (file) {
                // Construct path based on current location
                const basePath = currentPath === 'root' ? '../../media/music' : `../../media/music/${currentPath}`;
                audioPlayer.src = `${basePath}/${file.name}`;
                audioPlayer.play();
                isPlaying = true;
                
                nowPlaying.textContent = file.name.toUpperCase();
                playPauseBtn.textContent = '[PAUSE]';
                updatePlayingState();
            }
        }

        function updatePlayingState() {
            const items = document.querySelectorAll('.track-item.audio');
            const audioFiles = currentFiles.filter(f => f.type === 'audio');
            const currentFile = audioFiles[currentTrackIndex];
            
            items.forEach(item => {
                const itemName = item.querySelector('.track-name').textContent;
                item.classList.remove('selected', 'playing');
                if (currentFile && itemName === currentFile.name) {
                    if (!audioPlayer.paused) {
                        item.classList.add('playing');
                    } else {
                        item.classList.add('selected');
                    }
                }
            });
        }

        playPauseBtn.onclick = () => {
            if (isPlaying) {
                audioPlayer.pause();
                isPlaying = false;
                playPauseBtn.textContent = '[PLAY]';
            } else {
                if (currentTrackIndex >= 0) {
                    audioPlayer.play();
                    isPlaying = true;
                    playPauseBtn.textContent = '[PAUSE]';
                } else {
                    const audioFiles = currentFiles.filter(f => f.type === 'audio');
                    if (audioFiles.length > 0) playFile(0);
                }
            }
            updatePlayingState();
        };

        hideShowBtn.onclick = () => {
            const isHidden = playlistBox.style.display === 'none';
            playlistBox.style.display = isHidden ? 'block' : 'none';
            hideShowBtn.textContent = isHidden ? '[HIDE BROWSER]' : '[SHOW BROWSER]';
        };

        audioPlayer.addEventListener('timeupdate', () => {
            const current = formatTime(audioPlayer.currentTime);
            const total = formatTime(audioPlayer.duration);
            timeDisplay.textContent = `${current} / ${total}`;
        });

        audioPlayer.addEventListener('ended', () => {
            const audioFiles = currentFiles.filter(f => f.type === 'audio');
            if (currentTrackIndex < audioFiles.length - 1) {
                playFile(currentTrackIndex + 1);
            } else {
                isPlaying = false;
                playPauseBtn.textContent = '[PLAY]';
                updatePlayingState();
            }
        });

        audioPlayer.addEventListener('play', () => {
            isPlaying = true;
            updatePlayingState();
        });

        audioPlayer.addEventListener('pause', () => {
            isPlaying = false;
            updatePlayingState();
        });

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                playPauseBtn.click();
            }
        });

        function formatTime(seconds) {
            if (isNaN(seconds)) return '0:00';
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        loadManifest();

        // ============================================
        // ASCII GRID VISUALIZER
        // ============================================

        const canvas = document.getElementById('fireworks');
        const ctx = canvas.getContext('2d');
        let audioContext = null;
        let analyser = null;
        let dataArray = null;
        let animationId = null;

        // Grid settings
        const FONT_SIZE = 48;
        let CHAR_WIDTH = 0;
        let CHAR_HEIGHT = 0;
        let gridCols = 0;
        let gridRows = 0;
        let grid = [];

        // Character intensity levels (from dim to bright) - rectangular blocks only
        const INTENSITY_CHARS = [' ', '', '░', '▒', '▓', '▞', '★', '█'];

        // Particle system for grid lighting
        const particles = [];

        class Particle {
            constructor(x, y, vx, vy, energy) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.energy = energy * 2; // Double energy for more intensity
                this.life = 1.5; // Longer life
                this.decay = 0.008 + Math.random() * 0.008; // Slower decay
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.98;
                this.vy *= 0.98;
                this.life -= this.decay;
            }

            isDead() {
                return this.life <= 0;
            }
        }

        // Measure actual character dimensions
        function measureCharacterSize() {
            ctx.font = `${FONT_SIZE}px CommitMono`;
            ctx.textBaseline = 'top';

            // Measure width using a sample character
            const metrics = ctx.measureText('█');
            const baseWidth = metrics.width;

            // For monospaced fonts, height is typically fontSize * 1.2
            // But we can measure more precisely using actualBoundingBoxAscent + actualBoundingBoxDescent
            const baseHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;

            // Fallback if metrics not supported
            const measuredHeight = (!baseHeight || baseHeight === 0) ? FONT_SIZE * 1.2 : baseHeight;

            // Add gaps between characters (20% of character size)
            const GAP_RATIO = 0.2;
            CHAR_WIDTH = baseWidth * (1 + GAP_RATIO);
            CHAR_HEIGHT = measuredHeight * (1 + GAP_RATIO);
        }

        // Setup canvas and grid
        let gridOffsetX = 0;
        let gridOffsetY = 0;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Measure character size on each resize (important for responsive)
            measureCharacterSize();

            // Calculate grid to fill screen with one character border on all sides
            // Total columns/rows that could fit
            const totalCols = Math.floor(canvas.width / CHAR_WIDTH);
            const totalRows = Math.floor(canvas.height / CHAR_HEIGHT);

            // Usable grid space (minus 1 character border on each side)
            gridCols = Math.max(1, totalCols - 2);
            gridRows = Math.max(1, totalRows - 2);

            // Calculate centering offset to center the entire grid including borders
            const totalGridWidth = (gridCols + 2) * CHAR_WIDTH;
            const totalGridHeight = (gridRows + 2) * CHAR_HEIGHT;
            const startX = (canvas.width - totalGridWidth) / 2;
            const startY = (canvas.height - totalGridHeight) / 2;
            gridOffsetX = startX + CHAR_WIDTH;
            gridOffsetY = startY + CHAR_HEIGHT;

            // Initialize grid
            grid = [];
            for (let y = 0; y < gridRows; y++) {
                grid[y] = [];
                for (let x = 0; x < gridCols; x++) {
                    grid[y][x] = 0;
                }
            }
        }
        resizeCanvas();

        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                resizeCanvas();
            }, 150);
        });

        // Initialize Web Audio API
        function initAudioContext() {
            if (audioContext) return;

            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 512;

            const source = audioContext.createMediaElementSource(audioPlayer);
            source.connect(analyser);
            analyser.connect(audioContext.destination);

            const bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);
        }

        let burstTimer = 0;
        const BURST_INTERVAL = 15;

        // Animation loop
        function drawGrid() {
            animationId = requestAnimationFrame(drawGrid);

            // Decay grid
            for (let y = 0; y < gridRows; y++) {
                for (let x = 0; x < gridCols; x++) {
                    grid[y][x] *= 0.92; // Slower decay for more persistent brightness
                }
            }

            if (!analyser || audioPlayer.paused) {
                // Update existing particles
                for (let i = particles.length - 1; i >= 0; i--) {
                    particles[i].update();
                    lightGridCell(particles[i]);
                    if (particles[i].isDead()) {
                        particles.splice(i, 1);
                    }
                }
                renderGrid();
                return;
            }

            analyser.getByteFrequencyData(dataArray);

            // Calculate average energy
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const avgEnergy = sum / dataArray.length / 255;

            // Create bursts
            burstTimer++;
            if (burstTimer >= BURST_INTERVAL && avgEnergy > 0.1) {
                burstTimer = 0;
                createBurst(canvas.width / 2, canvas.height / 2, avgEnergy);
            }

            // Update particles and light grid
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                lightGridCell(particles[i]);
                if (particles[i].isDead()) {
                    particles.splice(i, 1);
                }
            }

            renderGrid();
        }

        function lightGridCell(particle) {
            // Account for grid offset when converting particle position to grid coordinates
            const gridX = Math.floor((particle.x - gridOffsetX) / CHAR_WIDTH);
            const gridY = Math.floor((particle.y - gridOffsetY) / CHAR_HEIGHT);

            if (gridX >= 0 && gridX < gridCols && gridY >= 0 && gridY < gridRows) {
                const intensity = particle.life * particle.energy;
                grid[gridY][gridX] = Math.max(grid[gridY][gridX], intensity);
            }
        }

        function renderGrid() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.font = `${FONT_SIZE}px CommitMono`;
            ctx.textBaseline = 'top';

            for (let y = 0; y < gridRows; y++) {
                for (let x = 0; x < gridCols; x++) {
                    const intensity = grid[y][x];
                    if (intensity > 0.05) {
                        const charIndex = Math.min(
                            Math.floor(intensity * INTENSITY_CHARS.length),
                            INTENSITY_CHARS.length - 1
                        );
                        const char = INTENSITY_CHARS[charIndex];

                        // Clamp intensity to show more at 100% opacity
                        ctx.globalAlpha = Math.min(intensity * 1.5, 1);
                        ctx.fillStyle = '#00ff99';
                        // Render with calculated grid offset using dynamic character dimensions
                        ctx.fillText(char, x * CHAR_WIDTH + gridOffsetX, y * CHAR_HEIGHT + gridOffsetY);
                    }
                }
            }
            ctx.globalAlpha = 1.0;
        }

        function createBurst(x, y, energy) {
            const particleCount = Math.floor(20 + energy * 40);

            for (let i = 0; i < particleCount; i++) {
                const angle = (Math.PI * 2 * i) / particleCount + Math.random() * 0.5;
                const speed = 15 + energy * 25; // Much higher speed to reach screen edges
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;

                particles.push(new Particle(x, y, vx, vy, energy));
            }
        }

        // Start visualizer when audio plays
        audioPlayer.addEventListener('play', () => {
            if (!audioContext) {
                initAudioContext();
            }
        });

        // Start animation loop
        drawGrid();
    </script>
    <script src="../../directory-component.js"></script>
</body>
</html>